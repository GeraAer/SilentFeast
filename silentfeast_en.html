<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Silent Feast / 暗宴 — beta ver. by Guo Ruizhi</title>
    <style>
        :root {
            --bg: #0e1016;
            --fg: #e7ecf5;
            --panel: #171b24;
            --panel2: #0f1420;
            --border: #2a3450;
            --acc: #7aa2ff;
            --good: #35d49a;
            --warn: #f6c343;
            --bad: #ff6b6b;
            --muted: #9aa4b2;
            --chip: #0f1322;
            --chip-b: #2d385c
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 16px;
            font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
            background: var(--bg);
            color: var(--fg)
        }

        h1 {
            margin: 6px 0 10px
        }

        .panel {
            border: 1px solid var(--border);
            border-radius: 12px;
            background: linear-gradient(180deg,var(--panel),var(--panel2));
            padding: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,.25)
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap
        }

        .villagers {
            display: grid;
            grid-template-columns: repeat(6,1fr);
            gap: 10px
        }

        .slot {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            min-height: 160px;
            background: #101527;
            position: relative;
            overflow: hidden
        }

        .title {
            font-weight: 800;
            margin-bottom: 6px
        }

        .tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 6px
        }

        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 999px;
            border: 1px solid var(--chip-b);
            background: var(--chip)
        }

        .retired {
            border-color: #a66;
            background: #3a2424
        }

        .garlic {
            border-color: #7a4;
            background: #33422a
        }

        .devline {
            color: #c7ccff;
            font-size: 12px;
            margin-top: 4px
        }

        .kpi {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px
        }

        .stat {
            display: grid;
            gap: 6px
        }

        .bar {
            height: 10px;
            border-radius: 999px;
            background: #0b0f1b;
            border: 1px solid var(--border);
            overflow: hidden
        }

            .bar > span {
                display: block;
                height: 100%;
                background: linear-gradient(90deg,var(--acc),#9ac5ff)
            }

            .bar.bad > span {
                background: linear-gradient(90deg,var(--bad),#ff9b9b)
            }

        .handchips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap
        }

        .chip {
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--chip-b);
            background: var(--chip);
            font-size: 12px
        }

        .controls label {
            margin-right: 8px
        }

        .btn {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0d1220;
            color: var(--fg);
            cursor: pointer
        }

            .btn:disabled {
                opacity: .5;
                cursor: not-allowed
            }

        select, input[type=number] {
            background: #0d1220;
            color: var(--fg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 6px 8px
        }

        .log {
            font-family: ui-monospace,Menlo,Consolas,monospace;
            max-height: 340px;
            overflow: auto;
            background: #0a0d13;
            color: #e9ecf1;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border)
        }

            .log .info {
                color: #c8d1e4
            }

            .log .good {
                color: var(--good)
            }

            .log .warn {
                color: var(--warn)
            }

            .log .bad {
                color: var(--bad)
            }

            .log .dev {
                color: #93b7ff
            }

        details.rulebook {
            margin: 12px 0
        }

            details.rulebook summary {
                cursor: pointer;
                font-weight: 800
            }

        .muted {
            color: var(--muted);
            font-size: 12px
        }

        .grid2 {
            display: grid;
            grid-template-columns: repeat(2,1fr);
            gap: 6px
        }

        .grid3 {
            display: grid;
            grid-template-columns: repeat(3,1fr);
            gap: 6px
        }

        .grid4 {
            display: grid;
            grid-template-columns: repeat(4,1fr);
            gap: 6px
        }

        .modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,.55);
            z-index: 1000
        }

            .modal .box {
                width: min(560px,92vw);
                background: linear-gradient(180deg,var(--panel),var(--panel2));
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 14px;
                box-shadow: 0 10px 30px rgba(0,0,0,.35)
            }

        .deck {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

            .deck .tag {
                background: #0f1530;
                border-color: #2b3a6a
            }

        .sectionTitle {
            margin-top: 6px;
            font-weight: 800
        }
    </style>
</head>
<body>
    <h1>Silent Feast / 暗宴 — beta ver by Guo Ruizhi aka Gera Aer</h1>

    <details class="rulebook" open>
        <summary>📖 Rulebook · Simplified</summary>
        <p><b>Goal</b>: Reach <b>50 BP</b> first to win; if either side's <b>Tox ≥ 15</b>, they burst.</p>
        <ul>
            <li><b>Public Card Stacks</b>: Each villager slot publicly displays its stack (N/G/C/A).</li>
            <li><b>Drinking Blood</b>: Drinking yourself draws <b>2</b> cards (resolve after adding to the slot's stack). Contains G → resolve G (drinker <b>+1×level</b> Tox, slot retires); otherwise if C−A≥2 → resolve V (drinker <b>+1×level</b> Tox); else resolve H (drinker <b>+1×level</b> BP).</li>
            <li><b>Chain Sucking</b>: Only on <b>your turn, when you designate yourself to drink</b>, if H is resolved, you can chain suck: 1st level=1, 2nd level=2... You can click "End Turn" to stop anytime. If any drink resolves V/G, end turn immediately and calculate Tox by current level.</li>
            <li><b>Designate Opponent to Drink</b>: Your turn <b>ends immediately</b>; the designated can choose to draw <b>1 / 2 / 3</b> cards for this drink, but <b>no chain sucking</b>. This drink's <b>level = your current chain + 1</b>.</li>
            <li><b>Peek</b> (tool): Only you can see the <b>top of the deck</b> ("the card before drawing this drink").</li>
            <li><b>Slay</b> (tool): Active slot → you +2BP and refresh; Retired slot → plunder all operation cards from its stack to your hand and refresh.</li>
            <li><b>Leech</b> (tool · once per game): Opponent -4BP; you +1Tox.</li>
            <li><b>Sacrifice Turn for Supply</b>: Before <b>any drinking in this turn</b>, you can forfeit the entire turn to get <b>2 operation cards</b> or <b>2 tools</b> from the market (unlimited by turns).</li>
            <li><b>Deck</b>: A truly shuffled physical operation card deck (can adjust counts of N/C/A/G in settings; G is fewer by default).</li>
        </ul>
    </details>

    <div class="row">
        <div class="panel" style="flex:1">
            <div class="kpi">
                <div class="panel stat">
                    <div><b>Your</b></div>
                    <div>BP <span id="pBP">0</span>/<span id="bpGoal">50</span></div>
                    <div class="bar"><span id="pBPbar" style="width:0%"></span></div>
                    <div>Tox <span id="pTox">0</span>/<span id="toxCap">15</span></div>
                    <div class="bar bad"><span id="pToxbar" style="width:0%"></span></div>
                    <div>Current chain level: <b id="pChain">0</b></div>
                    <div class="sectionTitle">Your Cards</div>
                    <div class="handchips" id="pHand"></div>
                </div>
                <div class="panel stat">
                    <div><b>AI</b></div>
                    <div>BP <span id="aBP">0</span>/<span id="bpGoal2">50</span></div>
                    <div class="bar"><span id="aBPbar" style="width:0%"></span></div>
                    <div>Tox <span id="aTox">0</span>/<span id="toxCap2">15</span></div>
                    <div class="bar bad"><span id="aToxbar" style="width:0%"></span></div>
                    <div>Current chain level: <b id="aChain">0</b></div>
                    <div class="sectionTitle">AI's Cards</div>
                    <div class="handchips" id="aHand"></div>
                </div>
            </div>

            <div class="panel" style="margin-top:10px">
                <div class="deck">
                    <b>Action Card Deck</b>
                    <span class="tag">Remaining <b id="deckCnt">0</b></span>
                    <span class="tag">N <b id="cntN">0</b></span>
                    <span class="tag">C <b id="cntC">0</b></span>
                    <span class="tag">A <b id="cntA">0</b></span>
                    <span class="tag garlic">G <b id="cntG">0</b></span>
                    <span class="muted" id="peekInfo">（Not peeked）</span>
                </div>
            </div>

            <div style="margin-top:10px"><b>Villagers (6 by default, public card stacks)</b></div>
            <div id="villagers" class="villagers"></div>
        </div>

        <div class="panel" style="flex:1">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <b>Settings</b>
                <div class="grid3">
                    <label><input type="checkbox" id="devToggle" /> Developer Mode</label>
                    <label>
                        AI Difficulty
                        <select id="aiDiff">
                            <option value="simple">Easy</option>
                            <option value="hard">Hard (Smart)</option>
                        </select>
                    </label>
                    <button id="restart" class="btn">New Game</button>
                </div>
            </div>
            <div class="panel grid2" style="margin-top:6px">
                <div>
                    <b>Goals / Thresholds</b>
                    <div class="grid4" style="margin-top:6px">
                        <label>BP Goal <input id="bpGoalInput" type="number" min="1" value="50" style="width:80px" /></label>
                        <label>Tox Cap <input id="toxCapInput" type="number" min="1" value="15" style="width:80px" /></label>
                    </div>
                </div>
                <div>
                    <b>Deck Composition (counts)</b>
                    <div class="grid4" style="margin-top:6px">
                        <label>N <input id="deckN" type="number" min="0" value="40" style="width:70px" /></label>
                        <label>C <input id="deckC" type="number" min="0" value="36" style="width:70px" /></label>
                        <label>A <input id="deckA" type="number" min="0" value="34" style="width:70px" /></label>
                        <label>G <input id="deckG" type="number" min="0" value="10" style="width:70px" /></label>
                    </div>
                </div>
            </div>
            <div class="grid3" style="margin-top:8px">
                <button id="applySettings" class="btn">Apply & Save</button>
                <button id="resetSettings" class="btn">Restore Defaults</button>
                <button id="endTurn" class="btn">End Turn (Abandon Chain)</button>
            </div>
            <hr />
            <div><b>Your Turn · Tool Phase (0–1 tool)</b></div>
            <div class="controls" style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:center">
                <label>
                    Tool:
                    <select id="toolSelect"><option value="">（None）</option></select>
                </label>
                <label>
                    Target slot:
                    <select id="toolTarget"></select>
                </label>
                <button id="playTool" class="btn">Use Tool / Leech</button>
                <div class="muted" style="grid-column:1/-1">Peek=see top of deck (only you); Slay=+2BP or plunder retired slot; Leech=once, opponent-4BP you+1Tox. Max 1 tool per turn.</div>
            </div>
            <hr />
            <div><b>Your Turn · Main Action</b></div>
            <div class="controls" style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:center">
                <label>
                    Target slot (can't choose retired):
                    <select id="mainTarget"></select>
                </label>
                <label>
                    Drinker:
                    <select id="drinker"><option value="player">I drink (draw 2)</option><option value="ai">Pass to AI (my turn ends immediately; AI can choose 1/2/3)</option></select>
                </label>
                <button id="doDrink" class="btn">Execute Drink / Designate Drink</button>
                <div class="muted" style="grid-column:1/-1">Self-drinking resolving H allows chain; designated drinkers can't chain; V/G Tox = <b>1×current level</b>.</div>
            </div>
            <div class="controls" style="display:grid;grid-template-columns:auto auto auto;gap:8px;align-items:center;margin-top:6px">
                <div class="muted">（Only usable if no drinking this turn yet）</div>
                <button id="supplyOp" class="btn">Sacrifice Turn: 2 Operations</button>
                <button id="supplyTool" class="btn">Sacrifice Turn: 2 Tools</button>
            </div>
        </div>
    </div>

    <div class="panel">
        <b>Game Log (public info; DEV mode shows AI details)</b>
        <div id="log" class="log"></div>
    </div>

    <!-- When designated as drinker: choose 1/2/3 cards to draw -->
    <div id="chooseDrawModal" class="modal" aria-hidden="true">
        <div class="box">
            <h3 style="margin-top:0">You are designated to drink: choose number of cards to draw</h3>
            <div class="muted">Standard is 2 cards; designated drinker can choose <b>1 / 2 / 3</b>. This drink's level is determined by the designator.</div>
            <div style="margin-top:8px">
                <label>
                    Number of cards to draw:
                    <select id="chooseDrawSel">
                        <option value="1">1 card (safer)</option>
                        <option value="2" selected>2 cards (standard)</option>
                        <option value="3">3 cards (riskier)</option>
                    </select>
                </label>
            </div>
            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
                <button id="chooseDrawOK" class="btn">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        /* ===== SFX ===== */
        let AC = null, sfxEnabled = true;
        function ensureAC() { if (!AC) { AC = new (window.AudioContext || window.webkitAudioContext)() } }
        function beep(freq = 440, dur = 0.12, type = 'sine', gain = 0.08) {
            if (!sfxEnabled) return; ensureAC(); const t = AC.currentTime, o = AC.createOscillator(), g = AC.createGain();
            o.type = type; o.frequency.value = freq; g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(gain, t + 0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur); o.connect(g).connect(AC.destination); o.start(t); o.stop(t + dur)
        }
        const SFX = { draw: () => beep(660, 0.08, 'triangle', 0.05), good: () => { beep(520, 0.09, 'sine', 0.07); setTimeout(() => beep(740, 0.09, 'sine', 0.05), 90) }, bad: () => { beep(180, 0.15, 'square', 0.06); setTimeout(() => beep(140, 0.15, 'square', 0.05), 120) }, garlic: () => { beep(300, 0.07, 'sawtooth', 0.06); setTimeout(() => beep(90, 0.2, 'square', 0.05), 60) }, slay: () => { beep(400, 0.05, 'square', 0.06); setTimeout(() => beep(250, 0.08, 'square', 0.05), 60) }, click: () => beep(500, 0.04, 'triangle', 0.04), pick: () => beep(720, 0.07, 'sine', 0.05) };

        /* ===== Utils & Log ===== */
        const el = id => document.getElementById(id);
        const logEl = el('log');
        function log(t, lv = 'info', devOnly = false) { if (devOnly && !state.settings.dev) return; const d = document.createElement('div'); d.className = (devOnly ? 'dev ' : '') + lv; d.innerHTML = t; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight }
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]] } return a }

        /* ===== Settings (persist) ===== */
        const STORE_KEY = 'sf_newrules_chainfix_v2';
        function defaults() {
            return {
                dev: false, aiDifficulty: 'simple',
                bpGoal: 50, toxCap: 15,
                deckCounts: { N: 40, C: 36, A: 34, G: 10 },
            }
        }
        function load() { try { const raw = localStorage.getItem(STORE_KEY); if (!raw) return defaults(); const s = JSON.parse(raw); return { ...defaults(), ...s, deckCounts: { ...defaults().deckCounts, ...(s.deckCounts || {}) } } } catch (e) { return defaults() } }
        function save() { localStorage.setItem(STORE_KEY, JSON.stringify(state.settings)) }

        /* ===== Core State ===== */
        const state = {
            settings: load(),
            deck: [], counts: { N: 0, C: 0, A: 0, G: 0 }, peek: null,
            player: { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 },
            ai: { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 },
            slots: Array.from({ length: 6 }, () => ({ stack: [], retired: false, publicRevealed: [] })),
            turn: 'player', usedToolThisTurn: false, ended: false,
            performedDrinkThisTurn: false
        };

        /* ===== Deck ===== */
        function buildDeck() {
            const c = state.settings.deckCounts; const arr = [];
            ['N', 'C', 'A', 'G'].forEach(k => { for (let i = 0; i < c[k]; i++)arr.push(k) });
            shuffle(arr); state.deck = arr; recount(); state.peek = null; updateDeckUI();
        }
        function drawOne() { if (state.deck.length === 0) buildDeck(); const x = state.deck.pop(); state.counts[x]--; updateDeckUI(); return x }
        function drawMany(n) { const out = []; for (let i = 0; i < n; i++) out.push(drawOne()); return out }
        function recount() { state.counts = { N: 0, C: 0, A: 0, G: 0 }; state.deck.forEach(x => state.counts[x]++) }
        function peekTop() { if (state.deck.length === 0) return null; return state.deck[state.deck.length - 1] }

        /* ===== Compute blood on a slot ===== */
        function computeType(slot) {
            if (slot.stack.includes('G')) return 'G';
            const c = slot.stack.filter(x => x === 'C').length;
            const a = slot.stack.filter(x => x === 'A').length;
            return (c - a >= 2) ? 'V' : 'H';
        }

        /* ===== UI helpers ===== */
        function chipList(owner) {
            const h = owner.hand, t = owner.tools, cnt = x => h.filter(c => c === x).length, tcnt = y => t.filter(c => c === y).length;
            return [
                `<span class="chip">Op N×${cnt('N')}</span>`,
                `<span class="chip">Op C×${cnt('C')}</span>`,
                `<span class="chip">Op A×${cnt('A')}</span>`,
                `<span class="chip">Op G×${cnt('G')}</span>`,
                `<span class="chip">Peek×${tcnt('Spy')}</span>`,
                `<span class="chip">Slay×${tcnt('Slay')}</span>`,
                `<span class="chip">Detox×${tcnt('Detox')}</span>`,
                `<span class="chip">Leech×${owner.leechUsed ? 0 : 1}</span>`
            ].join(' ')
        }
        function fillTargets(sel, aliveOnly = true) {
            sel.innerHTML = ''; state.slots.forEach((s, i) => { if (!aliveOnly || !s.retired) { sel.appendChild(new Option(`#${i + 1}`, String(i))) } });
        }
        function updateDeckUI() {
            el('deckCnt').textContent = state.deck.length;
            el('cntN').textContent = state.counts.N; el('cntC').textContent = state.counts.C; el('cntA').textContent = state.counts.A; el('cntG').textContent = state.counts.G;
            el('peekInfo').textContent = state.peek ? `（You peeked top card: ${state.peek}）` : '（Not peeked）'
        }
        function render() {
            el('pBP').textContent = state.player.bp; el('aBP').textContent = state.ai.bp;
            el('pTox').textContent = state.player.tox; el('aTox').textContent = state.ai.tox;
            el('bpGoal').textContent = state.settings.bpGoal; el('bpGoal2').textContent = state.settings.bpGoal;
            el('toxCap').textContent = state.settings.toxCap; el('toxCap2').textContent = state.settings.toxCap;
            el('pBPbar').style.width = Math.min(100, Math.round(100 * state.player.bp / state.settings.bpGoal)) + '%';
            el('aBPbar').style.width = Math.min(100, Math.round(100 * state.ai.bp / state.settings.bpGoal)) + '%';
            el('pToxbar').style.width = Math.min(100, Math.round(100 * state.player.tox / state.settings.toxCap)) + '%';
            el('aToxbar').style.width = Math.min(100, Math.round(100 * state.ai.tox / state.settings.toxCap)) + '%';
            el('pChain').textContent = state.player.chain; el('aChain').textContent = state.ai.chain;

            el('pHand').innerHTML = chipList(state.player);
            el('aHand').innerHTML = state.settings.dev ? chipList(state.ai) : '<span class="muted">（Hidden）</span>';

            const wrap = el('villagers'); wrap.innerHTML = '';
            state.slots.forEach((s, i) => {
                const d = document.createElement('div'); d.className = 'slot';
                const t = document.createElement('div'); t.className = 'title'; t.textContent = `#${i + 1}`; d.appendChild(t);
                const tags = document.createElement('div'); tags.className = 'tags';
                const ct = document.createElement('span'); ct.className = 'tag'; ct.textContent = `Stack:${s.stack.length}`; tags.appendChild(ct);
                if (s.retired) { const r = document.createElement('span'); r.className = 'tag retired'; r.textContent = 'Retired'; tags.appendChild(r) }
                if (s.stack.includes('G')) { const g = document.createElement('span'); g.className = 'tag garlic'; g.textContent = 'Has G'; tags.appendChild(g) }
                d.appendChild(tags);

                const list = document.createElement('div'); list.className = 'muted'; list.textContent = `Stack: [${s.stack.join(', ') || 'Empty'}]`;
                d.appendChild(list);
                const type = computeType(s); const line = document.createElement('div'); line.className = 'muted'; line.textContent = `Current result: ${type}`;
                d.appendChild(line);
                if (state.settings.dev && !s.retired) {
                    const dev = document.createElement('div'); dev.className = 'devline'; dev.textContent = `DEV: type=${type} stack=[${s.stack.join(', ')}]`;
                    d.appendChild(dev)
                }
                wrap.appendChild(d)
            });

            fillTargets(el('toolTarget'), false);
            fillTargets(el('mainTarget'), true);

            // tool list
            const tl = el('toolSelect'); tl.innerHTML = ''; tl.appendChild(new Option('（None）', ''));
            if (!state.player.leechUsed) tl.appendChild(new Option('Leech (Opponent -4BP, You +1Tox)', 'Leech'));
            if (state.player.tools.includes('Spy')) tl.appendChild(new Option('Peek (see top of deck)', 'Spy'));
            if (state.player.tools.includes('Slay')) tl.appendChild(new Option('Slay', 'Slay'));
            if (state.player.tools.includes('Detox')) tl.appendChild(new Option('Detox', 'Detox'));

            // buttons availability
            el('supplyOp').disabled = state.turn !== 'player' || state.performedDrinkThisTurn || state.ended;
            el('supplyTool').disabled = state.turn !== 'player' || state.performedDrinkThisTurn || state.ended;
            el('endTurn').disabled = state.turn !== 'player' || state.ended;

            el('devToggle').checked = state.settings.dev;
            el('aiDiff').value = state.settings.aiDifficulty;
            el('bpGoalInput').value = state.settings.bpGoal; el('toxCapInput').value = state.settings.toxCap;
            el('deckN').value = state.settings.deckCounts.N; el('deckC').value = state.settings.deckCounts.C; el('deckA').value = state.settings.deckCounts.A; el('deckG').value = state.settings.deckCounts.G;

            updateDeckUI();
        }

        /* ===== Start / Reset ===== */
        function resetBoard(villagerCount = 6) {
            state.player = { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 };
            state.ai = { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 };
            state.slots = Array.from({ length: villagerCount }, () => ({ stack: [], retired: false, publicRevealed: [] }));
            state.turn = 'player'; state.usedToolThisTurn = false; state.ended = false; state.peek = null; state.performedDrinkThisTurn = false;
            buildDeck(); log(`<b>Game Start</b>: Goal ${state.settings.bpGoal} BP; Tox cap ${state.settings.toxCap}; Draw to drink, public card stacks.`, 'info');
            render();
        }
        function checkEnd() {
            if (state.player.tox >= state.settings.toxCap) { log(`<b>You burst from toxin</b> (Tox ≥ ${state.settings.toxCap})`, 'bad'); state.ended = true }
            if (state.ai.tox >= state.settings.toxCap) { log(`<b>AI bursts from toxin</b> (Tox ≥ ${state.settings.toxCap})`, 'good'); state.ended = true }
            if (state.player.bp >= state.settings.bpGoal) { log(`<b>You reach ${state.settings.bpGoal} BP</b>`, 'good'); state.ended = true }
            if (state.ai.bp >= state.settings.bpGoal) { log(`<b>AI reaches ${state.settings.bpGoal} BP</b>`, 'bad'); state.ended = true }
            render(); return state.ended
        }

        /* ===== Tools ===== */
        function useTool() {
            if (state.ended || state.turn !== 'player') return;
            if (state.usedToolThisTurn) { log('Already used a tool this turn.', 'bad'); return }
            const sel = el('toolSelect').value; const idx = parseInt(el('toolTarget').value || '0', 10);
            if (!sel) { log('（You didn\'t use a tool this turn）', 'info'); return }

            if (sel === 'Leech') {
                if (state.player.leechUsed) { log('You already used Leech once.', 'bad'); return }
                state.player.leechUsed = true; state.ai.bp = Math.max(0, state.ai.bp - 4); state.player.tox += 1;
                log(`<b>You use Leech</b> → AI -4BP; You +1Tox`, 'warn'); state.usedToolThisTurn = true; render(); SFX.bad(); if (!checkEnd()) { }
                return
            }
            if (sel === 'Spy') {
                const i = state.player.tools.indexOf('Spy'); if (i < 0) { render(); return }
                state.player.tools.splice(i, 1);
                state.peek = peekTop();
                log(`You use <b>Peek</b> → You see top of deck: <b>${state.peek ?? '(Empty)'}</b> (only visible to you)`, 'info');
                state.usedToolThisTurn = true; render(); SFX.click(); return
            }
            if (sel === 'Slay') {
                const i = state.player.tools.indexOf('Slay'); if (i < 0) { render(); return }
                state.player.tools.splice(i, 1);
                const s = state.slots[idx];
                if (s.retired) {
                    const loot = [...s.stack]; state.player.hand.push(...loot);
                    log(`You use Slay on <b>retired</b> slot #${idx + 1} → Plunder its stack [${loot.join(', ') || 'None'}]; New villager added.`, 'warn'); SFX.slay();
                    state.slots[idx] = { stack: [], retired: false, publicRevealed: [] };
                } else {
                    state.player.bp += 2; log(`You use Slay on <b>active</b> slot #${idx + 1} → You +2BP; Slot refreshed.`, 'warn'); SFX.slay();
                    state.slots[idx] = { stack: [], retired: false, publicRevealed: [] };
                }
                state.usedToolThisTurn = true; render(); if (!checkEnd()) { }
                return
            }
            if (sel === 'Detox') {
                const i = state.player.tools.indexOf('Detox'); if (i < 0) { render(); return }
                state.player.tools.splice(i, 1);
                const self = confirm('Detox target: OK=Yourself, Cancel=AI');
                if (self) { state.player.tox = Math.max(0, state.player.tox - 1); log('You use Detox on yourself → Your Tox -1', 'info') }
                else { state.ai.tox = Math.max(0, state.ai.tox - 1); log('You use Detox on AI → AI Tox -1', 'info') }
                state.usedToolThisTurn = true; render(); SFX.good(); if (!checkEnd()) { }
                return
            }
        }

        /* ===== Drink Resolution (step-aware, forced no chain) ===== */
        function addToStackAndResolve(targetIdx, drinker, drawCount, step, allowChain) {
            // Draw cards and add to stack
            const got = drawMany(drawCount); SFX.draw();
            const s = state.slots[targetIdx];
            s.stack.push(...got);
            log(`${drinker === 'player' ? 'You' : 'AI'} draw at #${targetIdx + 1}: <b>[${got.join(', ') || 'Empty'}]</b> (added to stack; current level=${step})`, 'info');
            if (drinker === 'player') state.peek = null; // Peek invalidates after use

            // Determine result
            const type = computeType(s);
            if (type === 'G') {
                if (drinker === 'player') { state.player.tox += 1 * step; log(`→ Result <b>G</b>: You +${1 * step} Tox (level=${step}); #${targetIdx + 1} retires and reveals.`, 'warn'); SFX.garlic(); }
                else { state.ai.tox += 1 * step; log(`→ Result <b>G</b>: AI +${1 * step} Tox (level=${step}); #${targetIdx + 1} retires and reveals.`, 'warn'); SFX.garlic(); }
                s.retired = true; s.publicRevealed = [...s.stack];
                render(); return { type, ended: true };
            }
            if (type === 'V') {
                if (drinker === 'player') { state.player.tox += 1 * step; log(`→ Result <b>V</b>: You +${1 * step} Tox (level=${step})`, 'bad'); SFX.bad(); }
                else { state.ai.tox += 1 * step; log(`→ Result <b>V</b>: AI +${1 * step} Tox (level=${step})`, 'bad'); SFX.bad(); }
                render(); return { type, ended: true };
            }
            // H
            if (drinker === 'player') {
                state.player.bp += 1 * step;
                if (allowChain) { state.player.chain = step; log(`→ Result <b>H</b>: You +${1 * step} BP (chain level=${step})`, 'good'); }
                else { log(`→ Result <b>H</b>: You +${1 * step} BP (designated/no chain)`, 'good'); }
            } else {
                state.ai.bp += 1 * step;
                if (allowChain) { state.ai.chain = step; log(`→ Result <b>H</b>: AI +${1 * step} BP (chain level=${step})`, 'good'); }
                else { log(`→ Result <b>H</b>: AI +${1 * step} BP (designated/no chain)`, 'good'); }
            }
            render();
            return { type, ended: false };
        }

        /* ===== Player: drink / assign ===== */
        function playerDrinkOrAssign() {
            if (state.ended || state.turn !== 'player') return;
            const idx = parseInt(el('mainTarget').value || '0', 10); const who = el('drinker').value;
            if (state.slots[idx].retired) { log('This slot is retired, cannot choose.', 'bad'); return }
            // Mark that drinking has occurred this turn
            state.performedDrinkThisTurn = true;

            if (who === 'player') {
                // Self-drink: level = your current chain + 1; allow chain
                const step = (state.player.chain || 0) + 1;
                const res = addToStackAndResolve(idx, 'player', 2, step, true);
                if (res.ended) {
                    // Burst → end turn
                    state.player.chain = 0; endPlayerTurnCore();
                } else {
                    log(`Your self-drink results in H: can continue this turn (current chain level=${state.player.chain}).`, 'info');
                }
            } else {
                // Designate AI to drink: your turn ends immediately; use your "next level", AI can't chain
                const step = (state.player.chain || 0) + 1;
                const draw = aiChooseDrawCountWhenForced(idx);
                log(`You designate AI to drink at #${idx + 1} (AI chooses to draw <b>${draw}</b>; current level=${step})`, 'info');
                addToStackAndResolve(idx, 'ai', draw, step, false);
                state.player.chain = 0; endPlayerTurnCore();
            }
        }

        /* ===== End turn button ===== */
        function endPlayerTurnCore() {
            state.player.turns++; state.turn = 'ai'; state.usedToolThisTurn = false; state.performedDrinkThisTurn = false;
            render(); if (!checkEnd()) { log('—— AI\'s Turn ——', 'info'); aiTurn(); }
        }
        function endPlayerTurn() {
            if (state.ended || state.turn !== 'player') return;
            state.player.chain = 0; log('You choose to end your turn (abandon chain sucking).', 'info');
            endPlayerTurnCore();
        }

        /* ===== Supply (sacrifice turn; only before any drink this turn) ===== */
        function supply(kind) {
            if (state.ended || state.turn !== 'player') return;
            if (state.performedDrinkThisTurn) { log('Already drank this turn, cannot sacrifice for supply.', 'bad'); return; }

            if (kind === 'tool') {
                // Two choices: Spy / Slay / Detox (unlimited by turns)
                for (let t = 0; t < 2; t++) {
                    const pool = ['Spy', 'Slay', 'Detox']; shuffle(pool);
                    const pick = prompt(`Tool pick ${t + 1}/2: Enter Spy / Slay / Detox (leave empty for random)`)?.trim();
                    let got = ['Spy', 'Slay', 'Detox'].includes(pick) ? pick : pool[0];
                    state.player.tools.push(got); log(`You gain tool: +1 ${got}`, 'info'); SFX.pick();
                }
            } else {
                // 2 operations: draw two real cards from deck to "hand"
                for (let t = 0; t < 2; t++) {
                    const x = drawOne(); state.player.hand.push(x); log(`You gain operation: +1 ${x}`, 'info'); SFX.pick();
                }
            }
            // Sacrifice entire turn
            state.player.chain = 0; endPlayerTurnCore();
        }

        /* ===== AI ===== */
        function aiChooseDrawCountWhenForced(idx) {
            const s = state.slots[idx]; const c = s.stack.filter(x => x === 'C').length, a = s.stack.filter(x => x === 'A').length, diff = c - a;
            if (diff >= 1) return 1; if (diff <= -1) return 3; return 2;
        }

        function aiEvaluateSlot(idx) {
            const s = state.slots[idx];
            if (s.retired) return -Infinity;

            const type = computeType(s);
            const c = s.stack.filter(x => x === 'C').length;
            const a = s.stack.filter(x => x === 'A').length;
            const diff = c - a;

            // 基础评分
            let score = 0;

            // 根据当前类型评分
            if (type === 'H') score += 5;    // 好结果，加分
            else if (type === 'V') score -= 3; // 坏结果，减分
            else if (type === 'G') score -= 5; // 最坏结果，大减分

            // 考虑堆叠大小（太大的堆叠可能更危险）
            score -= s.stack.length * 0.2;

            // 考虑C和A的差异
            score += (a - c) * 0.5;

            return score;
        }

        function aiSelectBestSlot() {
            let bestScore = -Infinity;
            let bestIdx = 0;

            state.slots.forEach((_, idx) => {
                const score = aiEvaluateSlot(idx);
                if (score > bestScore) {
                    bestScore = score;
                    bestIdx = idx;
                }
            });

            return bestIdx;
        }

        function aiDecideToUseTool() {
            // 简单AI很少使用工具
            if (state.settings.aiDifficulty === 'simple' && Math.random() > 0.3) {
                return null;
            }

            // 困难AI更频繁使用工具
            if (state.settings.aiDifficulty === 'hard' && Math.random() > 0.1) {
                return null;
            }

            // 检查是否有可用工具
            if (state.ai.tools.length === 0 && state.ai.leechUsed) {
                return null;
            }

            // 决定使用哪种工具
            const possibleTools = [];

            if (!state.ai.leechUsed && state.ai.bp < state.player.bp - 5) {
                possibleTools.push('Leech');
            }

            if (state.ai.tools.includes('Slay')) {
                possibleTools.push('Slay');
            }

            if (state.ai.tools.includes('Spy')) {
                possibleTools.push('Spy');
            }

            if (state.ai.tools.includes('Detox') && state.ai.tox > 8) {
                possibleTools.push('Detox');
            }

            if (possibleTools.length === 0) {
                return null;
            }

            // 随机选择一个工具
            const tool = possibleTools[Math.floor(Math.random() * possibleTools.length)];
            let target = 0;

            if (tool === 'Slay') {
                // 选择最有价值的目标
                const activeSlots = state.slots.map((s, i) => ({i, score: s.retired ? 2 : 1}))
                    .sort((a, b) => b.score - a.score);
                target = activeSlots[0].i;
            } else {
                // 对其他工具，随机选择一个目标
                const validTargets = state.slots.map((_, i) => i).filter(i => !state.slots[i].retired);
                target = validTargets[Math.floor(Math.random() * validTargets.length)];
            }

            return {tool, target};
        }

        function aiDecideToChain() {
            // 基于当前连锁等级和难度决定是否继续连锁
            if (state.ai.chain === 0) return true; // 刚开始，总是继续

            // 简单AI更容易停止连锁
            if (state.settings.aiDifficulty === 'simple') {
                return Math.random() > 0.5 - (state.ai.chain * 0.1);
            }

            // 困难AI更倾向于继续连锁
            return Math.random() > 0.3 - (state.ai.chain * 0.05);
        }

        function aiPerformDrink() {
            const targetIdx = aiSelectBestSlot();
            const step = state.ai.chain + 1;

            // 决定是自己喝还是指定玩家喝
            let drinker = 'ai';
            let drawCount = 2;

            // 简单AI通常自己喝
            if (state.settings.aiDifficulty === 'simple' && Math.random() > 0.3) {
                drinker = 'ai';
            }
            // 困难AI在特定情况下会让玩家喝
            else if (state.settings.aiDifficulty === 'hard') {
                // 如果玩家毒素较高，让玩家喝
                if (state.player.tox > 10 && Math.random() > 0.2) {
                    drinker = 'player';
                    drawCount = 3; // 让玩家抽更多卡片增加风险
                }
                // 如果AI连锁等级高，让玩家喝来结束连锁
                else if (state.ai.chain > 3 && Math.random() > 0.3) {
                    drinker = 'player';
                    drawCount = aiChooseDrawCountWhenForced(targetIdx);
                }
            }

            if (drinker === 'ai') {
                log(`AI drinks from slot #${targetIdx + 1} (level=${step})`, 'info');
                const res = addToStackAndResolve(targetIdx, 'ai', 2, step, true);

                if (res.ended) {
                    // 如果结果是G或V，结束回合
                    state.ai.chain = 0;
                    return false;
                } else {
                    // 如果结果是H，决定是否继续连锁
                    const continueChain = aiDecideToChain();
                    if (!continueChain) {
                        log(`AI ends chain at level ${state.ai.chain}`, 'info');
                        state.ai.chain = 0;
                        return false;
                    }
                    return true; // 继续连锁
                }
            } else {
                // 指定玩家喝
                log(`AI designates you to drink from slot #${targetIdx + 1} (level=${step})`, 'info');
                state.ai.chain = 0;

                // 显示对话框让玩家选择抽卡数量
                const modal = el('chooseDrawModal');
                modal.style.display = 'flex';

                return new Promise(resolve => {
                    el('chooseDrawOK').onclick = () => {
                        const count = parseInt(el('chooseDrawSel').value, 10);
                        modal.style.display = 'none';
                        addToStackAndResolve(targetIdx, 'player', count, step, false);
                        resolve(false); // 玩家被指定喝后，AI回合结束
                    };
                });
            }
        }

        async function aiTurn() {
            if (state.ended || state.turn !== 'ai') return;

            // AI思考延迟，让玩家有时间阅读
            await new Promise(resolve => setTimeout(resolve, 1000));

            // 第一步：决定是否使用工具
            const toolDecision = aiDecideToUseTool();
            if (toolDecision) {
                const {tool, target} = toolDecision;
                log(`AI uses tool: ${tool} on slot #${target + 1}`, 'info');

                if (tool === 'Leech') {
                    state.ai.leechUsed = true;
                    state.player.bp = Math.max(0, state.player.bp - 4);
                    state.ai.tox += 1;
                    log(`AI uses Leech → You -4BP; AI +1Tox`, 'warn');
                    SFX.bad();
                }
                else if (tool === 'Spy') {
                    const i = state.ai.tools.indexOf('Spy');
                    if (i >= 0) state.ai.tools.splice(i, 1);
                    const topCard = peekTop();
                    log(`AI uses Peek (DEV: top card is ${topCard})`, 'info', true);
                    SFX.click();
                }
                else if (tool === 'Slay') {
                    const i = state.ai.tools.indexOf('Slay');
                    if (i >= 0) state.ai.tools.splice(i, 1);
                    const s = state.slots[target];

                    if (s.retired) {
                        const loot = [...s.stack];
                        state.ai.hand.push(...loot);
                        log(`AI uses Slay on retired slot #${target + 1} → Plunders stack [${loot.join(', ')}]`, 'info');
                        state.slots[target] = { stack: [], retired: false, publicRevealed: [] };
                    } else {
                        state.ai.bp += 2;
                        log(`AI uses Slay on active slot #${target + 1} → AI +2BP`, 'info');
                        state.slots[target] = { stack: [], retired: false, publicRevealed: [] };
                    }
                    SFX.slay();
                }
                else if (tool === 'Detox') {
                    const i = state.ai.tools.indexOf('Detox');
                    if (i >= 0) state.ai.tools.splice(i, 1);
                    // AI优先给自己解毒
                    state.ai.tox = Math.max(0, state.ai.tox - 1);
                    log(`AI uses Detox on itself → AI Tox -1`, 'info');
                    SFX.good();
                }

                render();
                if (checkEnd()) return;

                // 使用工具后等待一会儿
                await new Promise(resolve => setTimeout(resolve, 800));
            }

            // 第二步：决定是否牺牲回合获取补给
            let sacrifice = false;
            if (state.settings.aiDifficulty === 'hard') {
                // 困难AI在工具很少时可能会牺牲回合
                if (state.ai.tools.length < 2 && Math.random() > 0.7) {
                    sacrifice = true;
                    sacrifice = 'tool';
                }
                // 困难AI在操作卡很少时可能会牺牲回合
                else if (state.ai.hand.length < 3 && Math.random() > 0.6) {
                    sacrifice = true;
                    sacrifice = 'op';
                }
            } else {
                // 简单AI很少牺牲回合
                if (Math.random() > 0.9) {
                    sacrifice = true;
                    sacrifice = Math.random() > 0.5 ? 'tool' : 'op';
                }
            }

            if (sacrifice) {
                if (sacrifice === 'tool') {
                    log(`AI sacrifices turn to get 2 tools`, 'info');
                    for (let i = 0; i < 2; i++) {
                        const tools = ['Spy', 'Slay', 'Detox'];
                        const tool = tools[Math.floor(Math.random() * tools.length)];
                        state.ai.tools.push(tool);
                        log(`AI gains tool: ${tool}`, 'info', state.settings.dev);
                    }
                } else {
                    log(`AI sacrifices turn to get 2 operations`, 'info');
                    for (let i = 0; i < 2; i++) {
                        const card = drawOne();
                        state.ai.hand.push(card);
                        log(`AI gains operation: ${card}`, 'info', state.settings.dev);
                    }
                }

                // 结束AI回合
                state.ai.turns++;
                state.turn = 'player';
                state.ai.chain = 0;
                render();
                log('—— Your Turn ——', 'info');
                return;
            }

            // 第三步：执行饮用动作，可能有连锁
            state.ai.chain = 0;
            let continueChain = true;

            while (continueChain && !state.ended) {
                continueChain = await aiPerformDrink();
                if (checkEnd()) return;

                // 连锁之间的延迟
                if (continueChain) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }

            // 结束AI回合
            state.ai.turns++;
            state.turn = 'player';
            state.ai.chain = 0;
            render();
            log('—— Your Turn ——', 'info');
        }

        /* ===== Event Listeners ===== */
        function setupEvents() {
            el('restart').addEventListener('click', () => resetBoard());
            el('playTool').addEventListener('click', useTool);
            el('doDrink').addEventListener('click', playerDrinkOrAssign);
            el('endTurn').addEventListener('click', endPlayerTurn);
            el('supplyOp').addEventListener('click', () => supply('op'));
            el('supplyTool').addEventListener('click', () => supply('tool'));

            // 关闭选择抽卡数量的对话框
            el('chooseDrawOK').addEventListener('click', () => {
                el('chooseDrawModal').style.display = 'none';
            });

            // 应用设置
            el('applySettings').addEventListener('click', () => {
                state.settings.dev = el('devToggle').checked;
                state.settings.aiDifficulty = el('aiDiff').value;
                state.settings.bpGoal = parseInt(el('bpGoalInput').value, 10) || 50;
                state.settings.toxCap = parseInt(el('toxCapInput').value, 10) || 15;
                state.settings.deckCounts.N = parseInt(el('deckN').value, 10) || 0;
                state.settings.deckCounts.C = parseInt(el('deckC').value, 10) || 0;
                state.settings.deckCounts.A = parseInt(el('deckA').value, 10) || 0;
                state.settings.deckCounts.G = parseInt(el('deckG').value, 10) || 0;
                save();
                buildDeck();
                render();
                log('Settings applied and saved.', 'info');
            });

            // 重置设置
            el('resetSettings').addEventListener('click', () => {
                const def = defaults();
                state.settings = {...def};
                el('devToggle').checked = def.dev;
                el('aiDiff').value = def.aiDifficulty;
                el('bpGoalInput').value = def.bpGoal;
                el('toxCapInput').value = def.toxCap;
                el('deckN').value = def.deckCounts.N;
                el('deckC').value = def.deckCounts.C;
                el('deckA').value = def.deckCounts.A;
                el('deckG').value = def.deckCounts.G;
                save();
                buildDeck();
                render();
                log('Settings restored to defaults.', 'info');
            });
        }

        /* ===== Initialize ===== */
        setupEvents();
        resetBoard();
    </script>
</body>
</html>
