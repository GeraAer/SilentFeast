<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>æš—å®´ / Silent Feast â€” beta ver.  by Guo Ruizhi</title>
    <style>
        :root {
            --bg: #0e1016;
            --fg: #e7ecf5;
            --panel: #171b24;
            --panel2: #0f1420;
            --border: #2a3450;
            --acc: #7aa2ff;
            --good: #35d49a;
            --warn: #f6c343;
            --bad: #ff6b6b;
            --muted: #9aa4b2;
            --chip: #0f1322;
            --chip-b: #2d385c
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 16px;
            font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
            background: var(--bg);
            color: var(--fg)
        }

        h1 {
            margin: 6px 0 10px
        }

        .panel {
            border: 1px solid var(--border);
            border-radius: 12px;
            background: linear-gradient(180deg,var(--panel),var(--panel2));
            padding: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,.25)
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap
        }

        .villagers {
            display: grid;
            grid-template-columns: repeat(6,1fr);
            gap: 10px
        }

        .slot {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            min-height: 160px;
            background: #101527;
            position: relative;
            overflow: hidden
        }

        .title {
            font-weight: 800;
            margin-bottom: 6px
        }

        .tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 6px
        }

        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 999px;
            border: 1px solid var(--chip-b);
            background: var(--chip)
        }

        .retired {
            border-color: #a66;
            background: #3a2424
        }

        .garlic {
            border-color: #7a4;
            background: #33422a
        }

        .devline {
            color: #c7ccff;
            font-size: 12px;
            margin-top: 4px
        }

        .kpi {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px
        }

        .stat {
            display: grid;
            gap: 6px
        }

        .bar {
            height: 10px;
            border-radius: 999px;
            background: #0b0f1b;
            border: 1px solid var(--border);
            overflow: hidden
        }

            .bar > span {
                display: block;
                height: 100%;
                background: linear-gradient(90deg,var(--acc),#9ac5ff)
            }

            .bar.bad > span {
                background: linear-gradient(90deg,var(--bad),#ff9b9b)
            }

        .handchips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap
        }

        .chip {
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--chip-b);
            background: var(--chip);
            font-size: 12px
        }

        .controls label {
            margin-right: 8px
        }

        .btn {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0d1220;
            color: var(--fg);
            cursor: pointer
        }

            .btn:disabled {
                opacity: .5;
                cursor: not-allowed
            }

        select, input[type=number] {
            background: #0d1220;
            color: var(--fg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 6px 8px
        }

        .log {
            font-family: ui-monospace,Menlo,Consolas,monospace;
            max-height: 340px;
            overflow: auto;
            background: #0a0d13;
            color: #e9ecf1;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border)
        }

            .log .info {
                color: #c8d1e4
            }

            .log .good {
                color: var(--good)
            }

            .log .warn {
                color: var(--warn)
            }

            .log .bad {
                color: var(--bad)
            }

            .log .dev {
                color: #93b7ff
            }

        details.rulebook {
            margin: 12px 0
        }

            details.rulebook summary {
                cursor: pointer;
                font-weight: 800
            }

        .muted {
            color: var(--muted);
            font-size: 12px
        }

        .grid2 {
            display: grid;
            grid-template-columns: repeat(2,1fr);
            gap: 6px
        }

        .grid3 {
            display: grid;
            grid-template-columns: repeat(3,1fr);
            gap: 6px
        }

        .grid4 {
            display: grid;
            grid-template-columns: repeat(4,1fr);
            gap: 6px
        }

        .modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,.55);
            z-index: 1000
        }

            .modal .box {
                width: min(560px,92vw);
                background: linear-gradient(180deg,var(--panel),var(--panel2));
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 14px;
                box-shadow: 0 10px 30px rgba(0,0,0,.35)
            }

        .deck {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

            .deck .tag {
                background: #0f1530;
                border-color: #2b3a6a
            }

        .sectionTitle {
            margin-top: 6px;
            font-weight: 800
        }
    </style>
</head>
<body>
    <h1>æš—å®´ / Silent Feast â€” beta ver by Guo Ruizhi aka Gera Aerï¼‰</h1>

    <details class="rulebook" open>
        <summary>ğŸ“– è§„åˆ™ä¹¦ Â· æç®€</summary>
        <p><b>ç›®æ ‡</b>ï¼šå…ˆåˆ° <b>50 BP</b> èƒœï¼›ä»»ä¸€æ–¹ <b>Tox â‰¥ 15</b> çˆ†ã€‚</p>
        <ul>
            <li><b>æ˜ç‰Œå¡æ ˆ</b>ï¼šæ¯ä¸ªæ‘æ°‘ä½å…¬å¼€å±•ç¤ºå…¶æ ˆï¼ˆN/G/C/Aï¼‰ã€‚</li>
            <li><b>å–è¡€</b>ï¼šè‡ªé¥®æŠ½ <b>2</b> å¼ ï¼ˆåŠ å…¥è¯¥ä½æ ˆååˆ¤å®šï¼‰ã€‚å« G â†’ åˆ¤ Gï¼ˆé¥®è€… <b>+1Ã—é˜¶</b> Toxï¼Œä½é€€åœºï¼‰ï¼›å¦åˆ™è‹¥ Câˆ’Aâ‰¥2 â†’ åˆ¤ Vï¼ˆé¥®è€… <b>+1Ã—é˜¶</b> Toxï¼‰ï¼›å¦åˆ™åˆ¤ Hï¼ˆé¥®è€… <b>+1Ã—é˜¶</b> BPï¼‰ã€‚</li>
            <li><b>è¿å¸</b>ï¼šåªæœ‰åœ¨<b>ä½ è‡ªå·±å›åˆï¼Œä¸”ä½ æŒ‡å®šä½ è‡ªå·±å–</b>æ—¶ï¼Œè‹¥åˆ¤ H æ‰èƒ½è¿å¸ï¼šç¬¬ä¸€å£é˜¶=1ï¼Œç¬¬äºŒå£é˜¶=2â€¦ ä½ å¯éšæ—¶ç‚¹å‡»â€œç»“æŸå›åˆâ€æ”¾å¼ƒç»§ç»­è¿å¸ã€‚è‹¥ä»»ä¸€å£åˆ¤ V/Gï¼Œç«‹åˆ»ç»“æŸå›åˆå¹¶æŒ‰å½“å£é˜¶ç»“ç®— Toxã€‚</li>
            <li><b>æŒ‡å®šå¯¹æ‰‹é¥®ç”¨</b>ï¼šä½ çš„å›åˆ<b>ç«‹åˆ»ç»“æŸ</b>ï¼›è¢«æŒ‡å®šè€…å¯æ”¹æˆæœ¬å£æŠ½ <b>1 / 2 / 3</b> å¼ ï¼Œä½†<b>ä¸è§¦å‘è¿å¸</b>ã€‚æœ¬å£çš„<b>é˜¶=ä½ å½“å‰è¿å¸+1</b>ã€‚</li>
            <li><b>çª¥è§†</b>ï¼ˆé“å…·ï¼‰ï¼šä»…ä½ å¯è§<b>ç‰Œåº“é¡¶</b>ï¼ˆâ€œè¿™å£æŠ½ç‰Œå‰ä¸€å¼ â€ï¼‰ã€‚</li>
            <li><b>æ€æˆ®</b>ï¼ˆé“å…·ï¼‰ï¼šæœªé€€åœºä½ â†’ ä½  +2BP å¹¶åˆ·æ–°ï¼›é€€åœºä½ â†’ æ å¤ºå…¶æ ˆä¸Šå…¨éƒ¨æ“ä½œç‰Œå…¥æ‰‹å¹¶åˆ·æ–°ã€‚</li>
            <li><b>è¡€æ </b>ï¼ˆé“å…·Â·æ•´å±€ä¸€æ¬¡ï¼‰ï¼šå¯¹æ‰‹ -4BPï¼›ä½  +1Toxã€‚</li>
            <li><b>ç‰ºç‰²å›åˆè¡¥ç»™</b>ï¼šåœ¨<b>æœ¬å›åˆå°šæœªå–è¡€</b>ä¹‹å‰ï¼Œå¯æ”¾å¼ƒæ•´ä¸ªå›åˆä»å¸‚åœºæ‹¿ <b>æ“ä½œÃ—2</b> æˆ– <b>é“å…·Ã—2</b>ï¼ˆä¸å—å›åˆæ•°é™åˆ¶ï¼‰ã€‚</li>
            <li><b>ç‰Œåº“</b>ï¼šçœŸå®æ´—ç‰Œçš„å®ä½“æ“ä½œç‰Œåº“ï¼ˆå¯åœ¨è®¾ç½®é‡Œè°ƒæ•´ N/C/A/G çš„ç‰Œæ•°ï¼›é»˜è®¤ G æ›´å°‘ï¼‰ã€‚</li>
        </ul>
    </details>

    <div class="row">
        <div class="panel" style="flex:1">
            <div class="kpi">
                <div class="panel stat">
                    <div><b>ä½ </b></div>
                    <div>BP <span id="pBP">0</span>/<span id="bpGoal">50</span></div>
                    <div class="bar"><span id="pBPbar" style="width:0%"></span></div>
                    <div>Tox <span id="pTox">0</span>/<span id="toxCap">15</span></div>
                    <div class="bar bad"><span id="pToxbar" style="width:0%"></span></div>
                    <div>æœ¬å›åˆè¿å¸é˜¶ï¼š<b id="pChain">0</b></div>
                    <div class="sectionTitle">æˆ‘çš„å¡åº“</div>
                    <div class="handchips" id="pHand"></div>
                </div>
                <div class="panel stat">
                    <div><b>AI</b></div>
                    <div>BP <span id="aBP">0</span>/<span id="bpGoal2">50</span></div>
                    <div class="bar"><span id="aBPbar" style="width:0%"></span></div>
                    <div>Tox <span id="aTox">0</span>/<span id="toxCap2">15</span></div>
                    <div class="bar bad"><span id="aToxbar" style="width:0%"></span></div>
                    <div>æœ¬å›åˆè¿å¸é˜¶ï¼š<b id="aChain">0</b></div>
                    <div class="sectionTitle">AI å¡åº“</div>
                    <div class="handchips" id="aHand"></div>
                </div>
            </div>

            <div class="panel" style="margin-top:10px">
                <div class="deck">
                    <b>æ“ä½œç‰Œç‰Œåº“</b>
                    <span class="tag">ä½™é‡ <b id="deckCnt">0</b></span>
                    <span class="tag">N <b id="cntN">0</b></span>
                    <span class="tag">C <b id="cntC">0</b></span>
                    <span class="tag">A <b id="cntA">0</b></span>
                    <span class="tag garlic">G <b id="cntG">0</b></span>
                    <span class="muted" id="peekInfo">ï¼ˆæœªçª¥è§†ï¼‰</span>
                </div>
            </div>

            <div style="margin-top:10px"><b>æ‘æ°‘ï¼ˆé»˜è®¤ 6 ä½ï¼Œæ˜ç‰Œå¡æ ˆï¼‰</b></div>
            <div id="villagers" class="villagers"></div>
        </div>

        <div class="panel" style="flex:1">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <b>è®¾ç½® / Settings</b>
                <div class="grid3">
                    <label><input type="checkbox" id="devToggle" /> å¼€å‘è€…æ¨¡å¼</label>
                    <label>
                        AI éš¾åº¦
                        <select id="aiDiff">
                            <option value="simple">ç®€å•</option>
                            <option value="hard">å›°éš¾ï¼ˆèªæ˜ï¼‰</option>
                        </select>
                    </label>
                    <button id="restart" class="btn">æ–°å¼€ä¸€å±€</button>
                </div>
            </div>
            <div class="panel grid2" style="margin-top:6px">
                <div>
                    <b>ç›®æ ‡ / é˜ˆå€¼</b>
                    <div class="grid4" style="margin-top:6px">
                        <label>BP ç›®æ ‡ <input id="bpGoalInput" type="number" min="1" value="50" style="width:80px" /></label>
                        <label>Tox ä¸Šé™ <input id="toxCapInput" type="number" min="1" value="15" style="width:80px" /></label>
                    </div>
                </div>
                <div>
                    <b>ç‰Œåº“ç»„æˆï¼ˆç‰Œæ•°ï¼‰</b>
                    <div class="grid4" style="margin-top:6px">
                        <label>N <input id="deckN" type="number" min="0" value="40" style="width:70px" /></label>
                        <label>C <input id="deckC" type="number" min="0" value="36" style="width:70px" /></label>
                        <label>A <input id="deckA" type="number" min="0" value="34" style="width:70px" /></label>
                        <label>G <input id="deckG" type="number" min="0" value="10" style="width:70px" /></label>
                    </div>
                </div>
            </div>
            <div class="grid3" style="margin-top:8px">
                <button id="applySettings" class="btn">åº”ç”¨å¹¶ä¿å­˜</button>
                <button id="resetSettings" class="btn">æ¢å¤é»˜è®¤</button>
                <button id="endTurn" class="btn">ç»“æŸæœ¬å›åˆï¼ˆæ”¾å¼ƒè¿å¸ï¼‰</button>
            </div>
            <hr />
            <div><b>ä½ çš„å›åˆ Â· é“å…·é˜¶æ®µï¼ˆ0â€“1 å¼ ï¼‰</b></div>
            <div class="controls" style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:center">
                <label>
                    é“å…·ï¼š
                    <select id="toolSelect"><option value="">ï¼ˆä¸ä½¿ç”¨ï¼‰</option></select>
                </label>
                <label>
                    ç›®æ ‡ä½ï¼š
                    <select id="toolTarget"></select>
                </label>
                <button id="playTool" class="btn">ä½¿ç”¨é“å…· / è¡€æ </button>
                <div class="muted" style="grid-column:1/-1">çª¥è§†=çœ‹ç‰Œåº“é¡¶ï¼ˆä»…ä½ å¯è§ï¼‰ï¼›æ€æˆ®=+2BP æˆ–æ å¤ºé€€åœºä½ï¼›è¡€æ =ä¸€æ¬¡ï¼Œå¯¹æ‰‹-4BPä½ +1Toxã€‚æ¯å›åˆæœ€å¤š 1 å¼ é“å…·ã€‚</div>
            </div>
            <hr />
            <div><b>ä½ çš„å›åˆ Â· ä¸»è¡ŒåŠ¨</b></div>
            <div class="controls" style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:center">
                <label>
                    ç›®æ ‡ä½ï¼ˆä¸å¯é€‰é€€åœºï¼‰ï¼š
                    <select id="mainTarget"></select>
                </label>
                <label>
                    é¥®ç”¨è€…ï¼š
                    <select id="drinker"><option value="player">æˆ‘å–ï¼ˆæŠ½2ï¼‰</option><option value="ai">æ¨ç»™ AIï¼ˆæˆ‘å›åˆç«‹åˆ»ç»“æŸï¼›AI å¯é€‰ 1/2/3ï¼‰</option></select>
                </label>
                <button id="doDrink" class="btn">æ‰§è¡Œé¥®ç”¨ / æŒ‡å®šé¥®ç”¨</button>
                <div class="muted" style="grid-column:1/-1">è‡ªé¥®åˆ¤ H å¯è¿å¸ï¼›è¢«æŒ‡å®šè€…ä¸è¿å¸ï¼›V/G çš„ Tox = <b>1Ã—å½“å£é˜¶</b>ã€‚</div>
            </div>
            <div class="controls" style="display:grid;grid-template-columns:auto auto auto;gap:8px;align-items:center;margin-top:6px">
                <div class="muted">ï¼ˆä»…å½“æœ¬å›åˆå°šæœªå–è¡€æ—¶å¯ç”¨ï¼‰</div>
                <button id="supplyOp" class="btn">ç‰ºç‰²å›åˆï¼šæ“ä½œ Ã—2</button>
                <button id="supplyTool" class="btn">ç‰ºç‰²å›åˆï¼šé“å…· Ã—2</button>
            </div>
        </div>
    </div>

    <div class="panel">
        <b>å¯¹å±€æ—¥å¿—ï¼ˆå…¬å¼€ä¿¡æ¯ï¼›DEV å¼€å¯ä¼šè¿½åŠ AIç»†èŠ‚ï¼‰</b>
        <div id="log" class="log"></div>
    </div>

    <!-- è¢«æŒ‡å®šä¸ºé¥®ç”¨è€…æ—¶ï¼šé€‰æ‹©æŠ½ 1/2/3 -->
    <div id="chooseDrawModal" class="modal" aria-hidden="true">
        <div class="box">
            <h3 style="margin-top:0">ä½ è¢«æŒ‡å®šé¥®ç”¨ï¼šé€‰æ‹©æŠ½ç‰Œå¼ æ•°</h3>
            <div class="muted">æ ‡å‡†ä¸ºæŠ½ 2ï¼›è¢«æŒ‡å®šè€…å¯æ”¹ä¸ºæŠ½ <b>1 / 2 / 3</b>ã€‚æœ¬å£é˜¶ç”±æŒ‡å®šè€…å†³å®šã€‚</div>
            <div style="margin-top:8px">
                <label>
                    æŠ½ç‰Œå¼ æ•°ï¼š
                    <select id="chooseDrawSel">
                        <option value="1">1 å¼ ï¼ˆæ›´ç¨³ï¼‰</option>
                        <option value="2" selected>2 å¼ ï¼ˆæ ‡å‡†ï¼‰</option>
                        <option value="3">3 å¼ ï¼ˆæ›´èµŒï¼‰</option>
                    </select>
                </label>
            </div>
            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
                <button id="chooseDrawOK" class="btn">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <script>
        /* ===== SFX ===== */
        let AC = null, sfxEnabled = true;
        function ensureAC() { if (!AC) { AC = new (window.AudioContext || window.webkitAudioContext)() } }
        function beep(freq = 440, dur = 0.12, type = 'sine', gain = 0.08) {
            if (!sfxEnabled) return; ensureAC(); const t = AC.currentTime, o = AC.createOscillator(), g = AC.createGain();
            o.type = type; o.frequency.value = freq; g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(gain, t + 0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur); o.connect(g).connect(AC.destination); o.start(t); o.stop(t + dur)
        }
        const SFX = { draw: () => beep(660, 0.08, 'triangle', 0.05), good: () => { beep(520, 0.09, 'sine', 0.07); setTimeout(() => beep(740, 0.09, 'sine', 0.05), 90) }, bad: () => { beep(180, 0.15, 'square', 0.06); setTimeout(() => beep(140, 0.15, 'square', 0.05), 120) }, garlic: () => { beep(300, 0.07, 'sawtooth', 0.06); setTimeout(() => beep(90, 0.2, 'square', 0.05), 60) }, slay: () => { beep(400, 0.05, 'square', 0.06); setTimeout(() => beep(250, 0.08, 'square', 0.05), 60) }, click: () => beep(500, 0.04, 'triangle', 0.04), pick: () => beep(720, 0.07, 'sine', 0.05) };

        /* ===== Utils & Log ===== */
        const el = id => document.getElementById(id);
        const logEl = el('log');
        function log(t, lv = 'info', devOnly = false) { if (devOnly && !state.settings.dev) return; const d = document.createElement('div'); d.className = (devOnly ? 'dev ' : '') + lv; d.innerHTML = t; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight }
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]] } return a }

        /* ===== Settings (persist) ===== */
        const STORE_KEY = 'sf_newrules_chainfix_v2';
        function defaults() {
            return {
                dev: false, aiDifficulty: 'simple',
                bpGoal: 50, toxCap: 15,
                deckCounts: { N: 40, C: 36, A: 34, G: 10 },
            }
        }
        function load() { try { const raw = localStorage.getItem(STORE_KEY); if (!raw) return defaults(); const s = JSON.parse(raw); return { ...defaults(), ...s, deckCounts: { ...defaults().deckCounts, ...(s.deckCounts || {}) } } } catch (e) { return defaults() } }
        function save() { localStorage.setItem(STORE_KEY, JSON.stringify(state.settings)) }

        /* ===== Core State ===== */
        const state = {
            settings: load(),
            deck: [], counts: { N: 0, C: 0, A: 0, G: 0 }, peek: null,
            player: { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 },
            ai: { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 },
            slots: Array.from({ length: 6 }, () => ({ stack: [], retired: false, publicRevealed: [] })),
            turn: 'player', usedToolThisTurn: false, ended: false,
            performedDrinkThisTurn: false
        };

        /* ===== Deck ===== */
        function buildDeck() {
            const c = state.settings.deckCounts; const arr = [];
            ['N', 'C', 'A', 'G'].forEach(k => { for (let i = 0; i < c[k]; i++)arr.push(k) });
            shuffle(arr); state.deck = arr; recount(); state.peek = null; updateDeckUI();
        }
        function drawOne() { if (state.deck.length === 0) buildDeck(); const x = state.deck.pop(); state.counts[x]--; updateDeckUI(); return x }
        function drawMany(n) { const out = []; for (let i = 0; i < n; i++) out.push(drawOne()); return out }
        function recount() { state.counts = { N: 0, C: 0, A: 0, G: 0 }; state.deck.forEach(x => state.counts[x]++) }
        function peekTop() { if (state.deck.length === 0) return null; return state.deck[state.deck.length - 1] }

        /* ===== Compute blood on a slot ===== */
        function computeType(slot) {
            if (slot.stack.includes('G')) return 'G';
            const c = slot.stack.filter(x => x === 'C').length;
            const a = slot.stack.filter(x => x === 'A').length;
            return (c - a >= 2) ? 'V' : 'H';
        }

        /* ===== UI helpers ===== */
        function chipList(owner) {
            const h = owner.hand, t = owner.tools, cnt = x => h.filter(c => c === x).length, tcnt = y => t.filter(c => c === y).length;
            return [
                `<span class="chip">æ“ä½œ NÃ—${cnt('N')}</span>`,
                `<span class="chip">æ“ä½œ CÃ—${cnt('C')}</span>`,
                `<span class="chip">æ“ä½œ AÃ—${cnt('A')}</span>`,
                `<span class="chip">æ“ä½œ GÃ—${cnt('G')}</span>`,
                `<span class="chip">çª¥Ã—${tcnt('Spy')}</span>`,
                `<span class="chip">æ€Ã—${tcnt('Slay')}</span>`,
                `<span class="chip">è§£Ã—${tcnt('Detox')}</span>`,
                `<span class="chip">æ Ã—${owner.leechUsed ? 0 : 1}</span>`
            ].join(' ')
        }
        function fillTargets(sel, aliveOnly = true) {
            sel.innerHTML = ''; state.slots.forEach((s, i) => { if (!aliveOnly || !s.retired) { sel.appendChild(new Option(`#${i + 1}`, String(i))) } });
        }
        function updateDeckUI() {
            el('deckCnt').textContent = state.deck.length;
            el('cntN').textContent = state.counts.N; el('cntC').textContent = state.counts.C; el('cntA').textContent = state.counts.A; el('cntG').textContent = state.counts.G;
            el('peekInfo').textContent = state.peek ? `ï¼ˆä½ çª¥è§†åˆ°é¡¶ç‰Œï¼š${state.peek}ï¼‰` : 'ï¼ˆæœªçª¥è§†ï¼‰'
        }
        function render() {
            el('pBP').textContent = state.player.bp; el('aBP').textContent = state.ai.bp;
            el('pTox').textContent = state.player.tox; el('aTox').textContent = state.ai.tox;
            el('bpGoal').textContent = state.settings.bpGoal; el('bpGoal2').textContent = state.settings.bpGoal;
            el('toxCap').textContent = state.settings.toxCap; el('toxCap2').textContent = state.settings.toxCap;
            el('pBPbar').style.width = Math.min(100, Math.round(100 * state.player.bp / state.settings.bpGoal)) + '%';
            el('aBPbar').style.width = Math.min(100, Math.round(100 * state.ai.bp / state.settings.bpGoal)) + '%';
            el('pToxbar').style.width = Math.min(100, Math.round(100 * state.player.tox / state.settings.toxCap)) + '%';
            el('aToxbar').style.width = Math.min(100, Math.round(100 * state.ai.tox / state.settings.toxCap)) + '%';
            el('pChain').textContent = state.player.chain; el('aChain').textContent = state.ai.chain;

            el('pHand').innerHTML = chipList(state.player);
            el('aHand').innerHTML = state.settings.dev ? chipList(state.ai) : '<span class="muted">ï¼ˆéšè—ï¼‰</span>';

            const wrap = el('villagers'); wrap.innerHTML = '';
            state.slots.forEach((s, i) => {
                const d = document.createElement('div'); d.className = 'slot';
                const t = document.createElement('div'); t.className = 'title'; t.textContent = `#${i + 1}`; d.appendChild(t);
                const tags = document.createElement('div'); tags.className = 'tags';
                const ct = document.createElement('span'); ct.className = 'tag'; ct.textContent = `æ ˆæ·±:${s.stack.length}`; tags.appendChild(ct);
                if (s.retired) { const r = document.createElement('span'); r.className = 'tag retired'; r.textContent = 'é€€åœº'; tags.appendChild(r) }
                if (s.stack.includes('G')) { const g = document.createElement('span'); g.className = 'tag garlic'; g.textContent = 'å«G'; tags.appendChild(g) }
                d.appendChild(tags);

                const list = document.createElement('div'); list.className = 'muted'; list.textContent = `æ ˆï¼š[${s.stack.join(', ') || 'ç©º'}]`;
                d.appendChild(list);
                const type = computeType(s); const line = document.createElement('div'); line.className = 'muted'; line.textContent = `å½“å‰åˆ¤å®šï¼š${type}`;
                d.appendChild(line);
                if (state.settings.dev && !s.retired) {
                    const dev = document.createElement('div'); dev.className = 'devline'; dev.textContent = `DEV: type=${type} stack=[${s.stack.join(', ')}]`;
                    d.appendChild(dev)
                }
                wrap.appendChild(d)
            });

            fillTargets(el('toolTarget'), false);
            fillTargets(el('mainTarget'), true);

            // tool list
            const tl = el('toolSelect'); tl.innerHTML = ''; tl.appendChild(new Option('ï¼ˆä¸ä½¿ç”¨ï¼‰', ''));
            if (!state.player.leechUsed) tl.appendChild(new Option('è¡€æ ï¼ˆå¯¹æ‰‹-4BPï¼Œæˆ‘+1Toxï¼‰', 'Leech'));
            if (state.player.tools.includes('Spy')) tl.appendChild(new Option('çª¥è§†ï¼ˆçœ‹ç‰Œåº“é¡¶ï¼‰', 'Spy'));
            if (state.player.tools.includes('Slay')) tl.appendChild(new Option('æ€æˆ®', 'Slay'));
            if (state.player.tools.includes('Detox')) tl.appendChild(new Option('è§£æ¯’', 'Detox'));

            // buttons availability
            el('supplyOp').disabled = state.turn !== 'player' || state.performedDrinkThisTurn || state.ended;
            el('supplyTool').disabled = state.turn !== 'player' || state.performedDrinkThisTurn || state.ended;
            el('endTurn').disabled = state.turn !== 'player' || state.ended;

            el('devToggle').checked = state.settings.dev;
            el('aiDiff').value = state.settings.aiDifficulty;
            el('bpGoalInput').value = state.settings.bpGoal; el('toxCapInput').value = state.settings.toxCap;
            el('deckN').value = state.settings.deckCounts.N; el('deckC').value = state.settings.deckCounts.C; el('deckA').value = state.settings.deckCounts.A; el('deckG').value = state.settings.deckCounts.G;

            updateDeckUI();
        }

        /* ===== Start / Reset ===== */
        function resetBoard(villagerCount = 6) {
            state.player = { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 };
            state.ai = { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 };
            state.slots = Array.from({ length: villagerCount }, () => ({ stack: [], retired: false, publicRevealed: [] }));
            state.turn = 'player'; state.usedToolThisTurn = false; state.ended = false; state.peek = null; state.performedDrinkThisTurn = false;
            buildDeck(); log(`<b>å¯¹å±€å¼€å§‹</b>ï¼šç›®æ ‡ ${state.settings.bpGoal} BPï¼›Tox ä¸Šé™ ${state.settings.toxCap}ï¼›æŠ½ç‰Œå–è¡€ï¼Œæ˜ç‰Œå¡æ ˆã€‚`, 'info');
            render();
        }
        function checkEnd() {
            if (state.player.tox >= state.settings.toxCap) { log(`<b>ä½ ä¸­æ¯’çˆ†æ‰</b>ï¼ˆTox â‰¥ ${state.settings.toxCap}ï¼‰`, 'bad'); state.ended = true }
            if (state.ai.tox >= state.settings.toxCap) { log(`<b>AI ä¸­æ¯’çˆ†æ‰</b>ï¼ˆTox â‰¥ ${state.settings.toxCap}ï¼‰`, 'good'); state.ended = true }
            if (state.player.bp >= state.settings.bpGoal) { log(`<b>ä½ è¾¾æˆ ${state.settings.bpGoal} BP</b>`, 'good'); state.ended = true }
            if (state.ai.bp >= state.settings.bpGoal) { log(`<b>AI è¾¾æˆ ${state.settings.bpGoal} BP</b>`, 'bad'); state.ended = true }
            render(); return state.ended
        }

        /* ===== Tools ===== */
        function useTool() {
            if (state.ended || state.turn !== 'player') return;
            if (state.usedToolThisTurn) { log('æœ¬å›åˆå·²ç”¨è¿‡é“å…·ã€‚', 'bad'); return }
            const sel = el('toolSelect').value; const idx = parseInt(el('toolTarget').value || '0', 10);
            if (!sel) { log('ï¼ˆä½ æœ¬å›åˆæœªä½¿ç”¨é“å…·ï¼‰', 'info'); return }

            if (sel === 'Leech') {
                if (state.player.leechUsed) { log('ä½ å·²ç”¨è¿‡ä¸€æ¬¡è¡€æ ã€‚', 'bad'); return }
                state.player.leechUsed = true; state.ai.bp = Math.max(0, state.ai.bp - 4); state.player.tox += 1;
                log(`<b>ä½ å‘åŠ¨è¡€æ </b> â†’ AI -4BPï¼›ä½  +1Tox`, 'warn'); state.usedToolThisTurn = true; render(); SFX.bad(); if (!checkEnd()) { }
                return
            }
            if (sel === 'Spy') {
                const i = state.player.tools.indexOf('Spy'); if (i < 0) { render(); return }
                state.player.tools.splice(i, 1);
                state.peek = peekTop();
                log(`ä½ ä½¿ç”¨<b>çª¥è§†</b> â†’ ä½ çœ‹åˆ°ç‰Œåº“é¡¶ä¸ºï¼š<b>${state.peek ?? 'ï¼ˆç©ºï¼‰'}</b>ï¼ˆä»…ä½ å¯è§ï¼‰`, 'info');
                state.usedToolThisTurn = true; render(); SFX.click(); return
            }
            if (sel === 'Slay') {
                const i = state.player.tools.indexOf('Slay'); if (i < 0) { render(); return }
                state.player.tools.splice(i, 1);
                const s = state.slots[idx];
                if (s.retired) {
                    const loot = [...s.stack]; state.player.hand.push(...loot);
                    log(`ä½ å¯¹<b>é€€åœº</b>ä½ #${idx + 1} ä½¿ç”¨æ€æˆ® â†’ æ å¤ºå…¶æ ˆ [${loot.join(', ') || 'æ— '}] å…¥æ‰‹ï¼›è¡¥æ–°æ‘æ°‘ã€‚`, 'warn'); SFX.slay();
                    state.slots[idx] = { stack: [], retired: false, publicRevealed: [] };
                } else {
                    state.player.bp += 2; log(`ä½ å¯¹<b>æœªé€€åœº</b>ä½ #${idx + 1} ä½¿ç”¨æ€æˆ® â†’ ä½  +2BPï¼›è¯¥ä½åˆ·æ–°ã€‚`, 'warn'); SFX.slay();
                    state.slots[idx] = { stack: [], retired: false, publicRevealed: [] };
                }
                state.usedToolThisTurn = true; render(); if (!checkEnd()) { }
                return
            }
            if (sel === 'Detox') {
                const i = state.player.tools.indexOf('Detox'); if (i < 0) { render(); return }
                state.player.tools.splice(i, 1);
                const self = confirm('è§£æ¯’å¯¹è±¡ï¼šç¡®å®š=è‡ªå·±ï¼Œå–æ¶ˆ=AI');
                if (self) { state.player.tox = Math.max(0, state.player.tox - 1); log('ä½ å¯¹è‡ªå·±ä½¿ç”¨è§£æ¯’ â†’ ä½  Tox -1', 'info') }
                else { state.ai.tox = Math.max(0, state.ai.tox - 1); log('ä½ å¯¹ AI ä½¿ç”¨è§£æ¯’ â†’ AI Tox -1', 'info') }
                state.usedToolThisTurn = true; render(); SFX.good(); if (!checkEnd()) { }
                return
            }
        }

        /* ===== Drink Resolution (step-aware, forced no chain) ===== */
        function addToStackAndResolve(targetIdx, drinker, drawCount, step, allowChain) {
            // æŠ½ç‰Œå¹¶å…¥æ ˆ
            const got = drawMany(drawCount); SFX.draw();
            const s = state.slots[targetIdx];
            s.stack.push(...got);
            log(`${drinker === 'player' ? 'ä½ ' : 'AI'} åœ¨ #${targetIdx + 1} æŠ½ç‰Œï¼š<b>[${got.join(', ') || 'ç©º'}]</b>ï¼ˆå…¥æ ˆï¼›æœ¬å£é˜¶=${step}ï¼‰`, 'info');
            if (drinker === 'player') state.peek = null; // çª¥è§†ç”¨ä¸€æ¬¡ä½œåºŸ

            // åˆ¤å®š
            const type = computeType(s);
            if (type === 'G') {
                if (drinker === 'player') { state.player.tox += 1 * step; log(`â†’ åˆ¤ <b>G</b>ï¼šä½  +${1 * step} Toxï¼ˆé˜¶=${step}ï¼‰ï¼›#${targetIdx + 1} é€€åœºå¹¶å…¬å¼€ã€‚`, 'warn'); SFX.garlic(); }
                else { state.ai.tox += 1 * step; log(`â†’ åˆ¤ <b>G</b>ï¼šAI +${1 * step} Toxï¼ˆé˜¶=${step}ï¼‰ï¼›#${targetIdx + 1} é€€åœºå¹¶å…¬å¼€ã€‚`, 'warn'); SFX.garlic(); }
                s.retired = true; s.publicRevealed = [...s.stack];
                render(); return { type, ended: true };
            }
            if (type === 'V') {
                if (drinker === 'player') { state.player.tox += 1 * step; log(`â†’ åˆ¤ <b>V</b>ï¼šä½  +${1 * step} Toxï¼ˆé˜¶=${step}ï¼‰`, 'bad'); SFX.bad(); }
                else { state.ai.tox += 1 * step; log(`â†’ åˆ¤ <b>V</b>ï¼šAI +${1 * step} Toxï¼ˆé˜¶=${step}ï¼‰`, 'bad'); SFX.bad(); }
                render(); return { type, ended: true };
            }
            // H
            if (drinker === 'player') {
                state.player.bp += 1 * step;
                if (allowChain) { state.player.chain = step; log(`â†’ åˆ¤ <b>H</b>ï¼šä½  +${1 * step} BPï¼ˆè¿å¸é˜¶=${step}ï¼‰`, 'good'); }
                else { log(`â†’ åˆ¤ <b>H</b>ï¼šä½  +${1 * step} BPï¼ˆè¢«æŒ‡å®š/ç¦æ­¢è¿å¸ï¼‰`, 'good'); }
            } else {
                state.ai.bp += 1 * step;
                if (allowChain) { state.ai.chain = step; log(`â†’ åˆ¤ <b>H</b>ï¼šAI +${1 * step} BPï¼ˆè¿å¸é˜¶=${step}ï¼‰`, 'good'); }
                else { log(`â†’ åˆ¤ <b>H</b>ï¼šAI +${1 * step} BPï¼ˆè¢«æŒ‡å®š/ç¦æ­¢è¿å¸ï¼‰`, 'good'); }
            }
            render();
            return { type, ended: false };
        }

        /* ===== Player: drink / assign ===== */
        function playerDrinkOrAssign() {
            if (state.ended || state.turn !== 'player') return;
            const idx = parseInt(el('mainTarget').value || '0', 10); const who = el('drinker').value;
            if (state.slots[idx].retired) { log('è¯¥ä½å·²é€€åœºï¼Œä¸èƒ½é€‰æ‹©ã€‚', 'bad'); return }
            // æ ‡è®°æœ¬å›åˆå·²å–
            state.performedDrinkThisTurn = true;

            if (who === 'player') {
                // è‡ªé¥®ï¼šé˜¶ = ä½ å½“å‰è¿å¸ + 1ï¼›å…è®¸è¿å¸
                const step = (state.player.chain || 0) + 1;
                const res = addToStackAndResolve(idx, 'player', 2, step, true);
                if (res.ended) {
                    // çˆ†äº† â†’ å›åˆç»“æŸ
                    state.player.chain = 0; endPlayerTurnCore();
                } else {
                    log(`ä½ è‡ªé¥®ä¸º Hï¼šå¯ç»§ç»­æœ¬å›åˆï¼ˆå½“å‰è¿å¸é˜¶=${state.player.chain}ï¼‰ã€‚`, 'info');
                }
            } else {
                // æŒ‡å®š AI é¥®ç”¨ï¼šä½ çš„å›åˆç«‹åˆ»ç»“æŸï¼›è¿™å£ç”¨ä½ çš„â€œä¸‹ä¸€é˜¶â€ï¼ŒAI ä¸è¿å¸
                const step = (state.player.chain || 0) + 1;
                const draw = aiChooseDrawCountWhenForced(idx);
                log(`ä½ æŒ‡å®š AI é¥®ç”¨ #${idx + 1}ï¼ˆAI é€‰æ‹©æŠ½ <b>${draw}</b>ï¼›æœ¬å£é˜¶=${step}ï¼‰`, 'info');
                addToStackAndResolve(idx, 'ai', draw, step, false);
                state.player.chain = 0; endPlayerTurnCore();
            }
        }

        /* ===== End turn button ===== */
        function endPlayerTurnCore() {
            state.player.turns++; state.turn = 'ai'; state.usedToolThisTurn = false; state.performedDrinkThisTurn = false;
            render(); if (!checkEnd()) { log('â€”â€” è½®åˆ° AI â€”â€”', 'info'); aiTurn(); }
        }
        function endPlayerTurn() {
            if (state.ended || state.turn !== 'player') return;
            state.player.chain = 0; log('ä½ é€‰æ‹©ç»“æŸæœ¬å›åˆï¼ˆæ”¾å¼ƒç»§ç»­è¿å¸ï¼‰ã€‚', 'info');
            endPlayerTurnCore();
        }

        /* ===== Supply (sacrifice turn; only before any drink this turn) ===== */
        function supply(kind) {
            if (state.ended || state.turn !== 'player') return;
            if (state.performedDrinkThisTurn) { log('æœ¬å›åˆå·²å–è¡€ï¼Œä¸èƒ½è¿›è¡Œç‰ºç‰²è¡¥ç»™ã€‚', 'bad'); return; }

            if (kind === 'tool') {
                // ä¸¤æ¬¡é€‰æ‹©ï¼šSpy / Slay / Detoxï¼ˆä¸é™åˆ¶å›åˆæ•°ï¼‰
                for (let t = 0; t < 2; t++) {
                    const pool = ['Spy', 'Slay', 'Detox']; shuffle(pool);
                    const pick = prompt(`é“å…·ç¬¬ ${t + 1}/2 æ¬¡ï¼šè¾“å…¥ Spy / Slay / Detoxï¼ˆç•™ç©º=éšæœºï¼‰`)?.trim();
                    let got = ['Spy', 'Slay', 'Detox'].includes(pick) ? pick : pool[0];
                    state.player.tools.push(got); log(`ä½ è¡¥ç»™é“å…·ï¼š+1 ${got}`, 'info'); SFX.pick();
                }
            } else {
                // æ“ä½œÃ—2ï¼šä»ç‰Œåº“çœŸå®æŠ½ä¸¤å¼ å…¥â€œæ‰‹ç‰Œâ€
                for (let t = 0; t < 2; t++) {
                    const x = drawOne(); state.player.hand.push(x); log(`ä½ è¡¥ç»™æ“ä½œï¼š+1 ${x}`, 'info'); SFX.pick();
                }
            }
            // ç‰ºç‰²æ•´å›åˆ
            state.player.chain = 0; endPlayerTurnCore();
        }

        /* ===== AI ===== */
        function aiChooseDrawCountWhenForced(idx) {
            const s = state.slots[idx]; const c = s.stack.filter(x => x === 'C').length, a = s.stack.filter(x => x === 'A').length, diff = c - a;
            if (diff >= 1) return 1; if (diff <= -1) return 3; return 2;
        }
        function aiTurn() {
            if (state.ended || state.turn !== 'ai') return;
            state.ai.chain = 0;
            let aiDrankThisTurn = false;

            // â€”â€” é“å…·é˜¶æ®µï¼ˆä¿å‘½/æœºä¼šä¸»ä¹‰ï¼‰â€”â€”
            if (state.settings.aiDifficulty === 'hard') {
                if (state.ai.tools.includes('Detox') && state.ai.tox >= state.settings.toxCap - 1) {
                    state.ai.tools.splice(state.ai.tools.indexOf('Detox'), 1); state.ai.tox = Math.max(0, state.ai.tox - 1);
                    log('AI ä½¿ç”¨è§£æ¯’ â†’ AI Tox -1', 'info'); SFX.good(); render(); if (checkEnd()) return;
                }
                if (!state.ai.leechUsed && (state.player.bp >= state.settings.bpGoal - 6 || (state.ai.bp <= state.player.bp && state.player.bp >= 8))) {
                    state.ai.leechUsed = true; state.player.bp = Math.max(0, state.player.bp - 4); state.ai.tox += 1;
                    log('<b>AI å‘åŠ¨è¡€æ </b> â†’ ä½  -4BPï¼›AI +1Tox', 'warn'); SFX.bad(); render(); if (checkEnd()) return;
                }
                if (state.ai.tools.includes('Spy') && Math.random() < 0.35) {
                    const i = state.ai.tools.indexOf('Spy'); state.ai.tools.splice(i, 1);
                    const top = peekTop(); log(`AI ä½¿ç”¨çª¥è§†ï¼ˆDEV å¯è§ï¼‰ï¼šé¡¶ç‰Œ=${top ?? 'ï¼ˆç©ºï¼‰'}`, 'info'); log(`DEVï¼šAI peek = ${top}`, 'dev', true);
                }
            } else {
                if (state.ai.tools.includes('Detox') && state.ai.tox >= state.settings.toxCap - 1) {
                    state.ai.tools.splice(state.ai.tools.indexOf('Detox'), 1); state.ai.tox = Math.max(0, state.ai.tox - 1);
                    log('AI ä½¿ç”¨è§£æ¯’ â†’ AI Tox -1', 'info'); SFX.good(); render(); if (checkEnd()) return;
                }
            }

            // â€”â€” å†³ç­–ï¼šè‹¥æœªå–å‰ï¼ŒAI ä¹Ÿå¯èƒ½ç‰ºç‰²å›åˆè¡¥ç»™ï¼ˆå°‘é‡æ¦‚ç‡ï¼‰â€”â€”
            if (Math.random() < 0.08) {
                // éšæœºé€‰æ‹©è¡¥ä»€ä¹ˆ
                if (Math.random() < 0.5) {
                    for (let k = 0; k < 2; k++) { const x = drawOne(); state.ai.hand.push(x); log(`AI ç‰ºç‰²å›åˆï¼šè¡¥ç»™æ“ä½œ +1 ${x}`, 'info') }
                } else {
                    for (let k = 0; k < 2; k++) { const pool = ['Spy', 'Slay', 'Detox']; shuffle(pool); state.ai.tools.push(pool[0]); log('AI ç‰ºç‰²å›åˆï¼šè¡¥ç»™é“å…· +1', 'info') }
                }
                state.ai.turns++; state.turn = 'player'; render(); if (!checkEnd()) { log('â€”â€” è½®åˆ°ä½  â€”â€”', 'info') } return;
            }

            // â€”â€” ä¸»è¡ŒåŠ¨ï¼šè¯„ä¼°æ¯ä¸ªæœªé€€åœºä½ â€”â€”
            const candIdx = state.slots.map((s, i) => !s.retired ? i : -1).filter(i => i >= 0);
            let bestSelf = null, bestSelfScore = -1e9;
            let bestPush = null, bestPushScore = -1e9;
            candIdx.forEach(i => {
                const s = state.slots[i]; const cur = computeType(s);
                const selfScore = (cur === 'H' ? +2 : cur === 'V' ? -2 * (1 + state.ai.tox / state.settings.toxCap) : -1.5);
                if (selfScore > bestSelfScore) { bestSelfScore = selfScore; bestSelf = i }
                const pushScore = (cur === 'V' ? +2 * (1 + state.player.tox / state.settings.toxCap) : cur === 'G' ? +1.2 : -1.0);
                if (pushScore > bestPushScore) { bestPushScore = pushScore; bestPush = i }
            });

            // å¶å°”å¯¹é€€åœºä½ç”¨æ€æˆ®æ å¤º
            const retiredIdx = state.slots.map((s, i) => s.retired ? i : -1).filter(i => i >= 0);
            if (state.ai.tools.includes('Slay') && retiredIdx.length && Math.random() < 0.5) {
                const i = state.ai.tools.indexOf('Slay'); state.ai.tools.splice(i, 1);
                const pick = rnd(retiredIdx); const loot = [...state.slots[pick].stack]; state.ai.hand.push(...loot);
                log(`AI å¯¹é€€åœºä½ #${pick + 1} ä½¿ç”¨æ€æˆ®ï¼ˆæ å¤ºå…¥æ‰‹ï¼‰`, 'warn'); SFX.slay(); state.slots[pick] = { stack: [], retired: false, publicRevealed: [] };
                state.ai.turns++; state.turn = 'player'; render(); if (!checkEnd()) { log('â€”â€” è½®åˆ°ä½  â€”â€”', 'info') } return;
            }

            // å†³å®šè‡ªé¥® or æ¨ä½ å–
            const preferSelf = bestSelfScore >= bestPushScore - 0.3;
            if (preferSelf && bestSelf != null) {
                const idx = bestSelf;
                // è‡ªé¥®ï¼šæ¯å£é˜¶ = AI.chain + 1ï¼›H å¯è¿å¸ï¼›V/G ç»“æŸ
                do {
                    const step = (state.ai.chain || 0) + 1;
                    const res = addToStackAndResolve(idx, 'ai', 2, step, true);
                    aiDrankThisTurn = true;
                    if (res.ended) { state.ai.chain = 0; break; }
                    const risk = state.ai.tox / state.settings.toxCap;
                    const goOn = (state.ai.chain < 3) && (risk < 0.5) && Math.random() < 0.65;
                    if (!goOn) break;
                } while (true);
                state.ai.turns++; state.turn = 'player'; render(); if (!checkEnd()) { log('â€”â€” è½®åˆ°ä½  â€”â€”', 'info') } return;
            } else if (bestPush != null) {
                const idx = bestPush;
                const step = (state.ai.chain || 0) + 1;
                log(`AI æŒ‡å®šä½ é¥®ç”¨ #${idx + 1}ï¼ˆä½ å¯é€‰æŠ½ 1/2/3ï¼›æœ¬å£é˜¶=${step}ï¼‰`, 'info');
                showChooseDrawModal((n) => {
                    addToStackAndResolve(idx, 'player', n, step, false);
                    state.ai.chain = 0; state.ai.turns++; state.turn = 'player';
                    render(); if (!checkEnd()) { log('â€”â€” è½®åˆ°ä½  â€”â€”', 'info') }
                });
                return;
            }

            // fallbackï¼šç»“æŸ
            state.ai.turns++; state.turn = 'player'; render(); if (!checkEnd()) { log('â€”â€” è½®åˆ°ä½  â€”â€”', 'info') }
        }

        /* ===== Modal: choose draw count when forced ===== */
        function showChooseDrawModal(cb) {
            const m = el('chooseDrawModal'); const s = el('chooseDrawSel'); m.style.display = 'flex';
            el('chooseDrawOK').onclick = () => { try { ensureAC() } catch (e) { } SFX.click(); const n = parseInt(s.value, 10); m.style.display = 'none'; cb(n) }
        }

        /* ===== Small helpers ===== */
        function rnd(a) { return a[(Math.random() * a.length) | 0] }

        /* ===== Wiring ===== */
        ['applySettings', 'resetSettings', 'restart', 'playTool', 'doDrink', 'supplyOp', 'supplyTool', 'endTurn'].forEach(id => {
            el(id).addEventListener('click', () => { try { ensureAC() } catch (e) { } SFX.click() })
        });
        el('applySettings').onclick = () => {
            state.settings.dev = el('devToggle').checked;
            state.settings.aiDifficulty = el('aiDiff').value;
            state.settings.bpGoal = Math.max(1, parseInt(el('bpGoalInput').value || '50', 10));
            state.settings.toxCap = Math.max(1, parseInt(el('toxCapInput').value || '15', 10));
            state.settings.deckCounts = {
                N: Math.max(0, parseInt(el('deckN').value || '40', 10)),
                C: Math.max(0, parseInt(el('deckC').value || '36', 10)),
                A: Math.max(0, parseInt(el('deckA').value || '34', 10)),
                G: Math.max(0, parseInt(el('deckG').value || '10', 10))
            };
            save(); log('è®¾ç½®å·²åº”ç”¨å¹¶ä¿å­˜ã€‚', 'info'); buildDeck(); render();
        };
        el('resetSettings').onclick = () => { state.settings = defaults(); save(); buildDeck(); render(); log('è®¾ç½®å·²æ¢å¤é»˜è®¤ã€‚', 'info') };
        el('restart').onclick = () => { resetBoard(6) };
        el('playTool').onclick = useTool;
        el('doDrink').onclick = playerDrinkOrAssign;
        el('supplyOp').onclick = () => supply('op');
        el('supplyTool').onclick = () => supply('tool');
        el('endTurn').onclick = endPlayerTurn;
        el('devToggle').addEventListener('change', () => { state.settings.dev = el('devToggle').checked; save(); render() });

        /* ===== Init ===== */
        resetBoard(6);
    </script>
    <script>
        // è®¡ç®—æ‘æ°‘è¡€æ¶²ç±»å‹ï¼ˆV/G/Hï¼‰
        function computeType(slot) {
            if (slot.stack.includes('G')) return 'G';  // å¦‚æœæ ˆä¸­æœ‰Gè¡€ï¼Œåˆ¤å®šä¸ºGè¡€
            const c = slot.stack.filter(x => x === 'C').length;
            const a = slot.stack.filter(x => x === 'A').length;
            return (c - a >= 2) ? 'V' : 'H';  // C-A >= 2 ä¸ºVï¼Œå¦åˆ™ä¸ºHè¡€
        }

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ‘æ°‘éƒ½ä¸ºVæˆ–Gï¼Œå¦‚æœæ˜¯ï¼Œè¡¥å……ä¸€ä¸ªæ–°ç™½æ¿æ‘æ°‘
        function checkForWhiteboardVillager() {
            const allVillagersRetiredOrV_G = state.slots.every(slot => {
                const type = computeType(slot);
                return type === 'V' || type === 'G';  // å¦‚æœå…¨éƒ¨æ‘æ°‘éƒ½æ˜¯Væˆ–Gè¡€
            });

            if (allVillagersRetiredOrV_G) {
                // å¦‚æœæ˜¯ï¼Œè¡¥å……ä¸€ä¸ªæ–°çš„ç™½æ¿æ‘æ°‘
                log("æ‰€æœ‰æ‘æ°‘å·²è¢«åˆ¤å®šä¸ºVæˆ–Gè¡€ï¼Œè¡¥å……ä¸€ä¸ªæ–°é²œç™½æ¿æ‘æ°‘", 'info');
                addNewVillager();
            }
        }

        // æ·»åŠ ä¸€ä¸ªæ–°ç™½æ¿æ‘æ°‘ï¼ˆè¡€æ¶²ä¸ºHï¼‰
        function addNewVillager() {
            const newVillager = {
                stack: ['H'],  // è®¾ç½®æ–°æ‘æ°‘çš„è¡€æ¶²ç±»å‹ä¸ºH
                retired: false,
                publicRevealed: []
            };

            // å°†æ–°çš„æ‘æ°‘åŠ å…¥åˆ°slotsä¸­
            state.slots.push(newVillager);
            render();  // é‡æ–°æ¸²æŸ“ç•Œé¢
        }

        // é‡ç½®æ‘æ°‘å’Œæ¸¸æˆçŠ¶æ€
        function resetBoard(villagerCount = 6) {
            state.player = { bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 };
            state.ai = Array.from({ length: 1 }).map(() => ({ bp: 0, tox: 0, hand: [], tools: [], chain: 0, leechUsed: false, turns: 0 }));
            state.slots = Array.from({ length: villagerCount }, () => ({ stack: ['H'], retired: false, publicRevealed: [] }));
            state.turn = 'player'; state.usedToolThisTurn = false; state.ended = false; state.peek = null; state.performedDrinkThisTurn = false;
            buildDeck(); log(`<b>å¯¹å±€å¼€å§‹</b>ï¼šç›®æ ‡ ${state.settings.bpGoal} BPï¼›Tox ä¸Šé™ ${state.settings.toxCap}ï¼›æŠ½ç‰Œå–è¡€ï¼Œæ˜ç‰Œå¡æ ˆã€‚`, 'info');
            render();
        }

        // è°ƒç”¨æ£€æŸ¥å‡½æ•°ï¼šæ¯å›åˆæˆ–æ¯æ¬¡æ“ä½œåè°ƒç”¨
        function endPlayerTurnCore() {
            checkForWhiteboardVillager(); // æ£€æŸ¥æ˜¯å¦éœ€è¦è¡¥å……æ–°æ‘æ°‘
            state.player.turns++; state.turn = 'ai'; state.usedToolThisTurn = false; state.performedDrinkThisTurn = false;
            render(); if (!checkEnd()) { log('â€”â€” è½®åˆ° AI â€”â€”', 'info'); aiTurn(); }
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        el('restart').onclick = () => { resetBoard(6); };

        // æ¸²æŸ“æ›´æ–°UI
        function render() {
            // æ›´æ–°ç•Œé¢ï¼Œæ˜¾ç¤ºå½“å‰ç©å®¶å’ŒAIçš„çŠ¶æ€
            el('pBP').textContent = state.player.bp; el('aBP').textContent = state.ai.bp;
            el('pTox').textContent = state.player.tox; el('aTox').textContent = state.ai.tox;
            el('bpGoal').textContent = state.settings.bpGoal; el('bpGoal2').textContent = state.settings.bpGoal;
            el('toxCap').textContent = state.settings.toxCap; el('toxCap2').textContent = state.settings.toxCap;
            el('pBPbar').style.width = Math.min(100, Math.round(100 * state.player.bp / state.settings.bpGoal)) + '%';
            el('aBPbar').style.width = Math.min(100, Math.round(100 * state.ai.bp / state.settings.bpGoal)) + '%';
            el('pToxbar').style.width = Math.min(100, Math.round(100 * state.player.tox / state.settings.toxCap)) + '%';
            el('aToxbar').style.width = Math.min(100, Math.round(100 * state.ai.tox / state.settings.toxCap)) + '%';
            el('pChain').textContent = state.player.chain; el('aChain').textContent = state.ai.chain;

            // æ›´æ–°æ‘æ°‘æ˜¾ç¤º
            const wrap = el('villagers'); wrap.innerHTML = '';
            state.slots.forEach((s, i) => {
                const d = document.createElement('div'); d.className = 'slot';
                const t = document.createElement('div'); t.className = 'title'; t.textContent = `#${i + 1}`; d.appendChild(t);
                const tags = document.createElement('div'); tags.className = 'tags';
                const ct = document.createElement('span'); ct.className = 'tag'; ct.textContent = `æ ˆæ·±:${s.stack.length}`; tags.appendChild(ct);
                if (s.retired) { const r = document.createElement('span'); r.className = 'tag retired'; r.textContent = 'é€€åœº'; tags.appendChild(r) }
                if (s.stack.includes('G')) { const g = document.createElement('span'); g.className = 'tag garlic'; g.textContent = 'å«G'; tags.appendChild(g) }
                d.appendChild(tags);

                const list = document.createElement('div'); list.className = 'muted'; list.textContent = `æ ˆï¼š[${s.stack.join(', ') || 'ç©º'}]`;
                d.appendChild(list);
                const type = computeType(s); const line = document.createElement('div'); line.className = 'muted'; line.textContent = `å½“å‰åˆ¤å®šï¼š${type}`;
                d.appendChild(line);
                if (state.settings.dev && !s.retired) {
                    const dev = document.createElement('div'); dev.className = 'devline'; dev.textContent = `DEV: type=${type} stack=[${s.stack.join(', ')}]`;
                    d.appendChild(dev)
                }
                wrap.appendChild(d)
            });
        }
    </script>


</body>
</html>
